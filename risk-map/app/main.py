# risk-map/app/main.py
import os
from typing import Any, Dict, Optional

import asyncpg
from fastapi import FastAPI, HTTPException, Path
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware
from fastapi.responses import Response, JSONResponse
from dotenv import load_dotenv

load_dotenv()

DB_URL = os.environ["MAP_DATABASE_URL"]  # e.g. postgresql://map_backend.<ref>:pass@aws-1-...pooler...:6543/postgres?sslmode=require

# A tiny Response subclass so OpenAPI shows the correct MVT media-type
class MVTResponse(Response):
    media_type = "application/vnd.mapbox-vector-tile"

# ---------------------------------------------------------------------
# App + middleware
# ---------------------------------------------------------------------

app = FastAPI(title="Risk Map API")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],     # tighten for prod
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Compress large responses (MVTs are small-ish, but this helps other endpoints)
app.add_middleware(GZipMiddleware, minimum_size=1500)

# ---------------------------------------------------------------------
# Startup / shutdown: db pool (PgBouncer-safe)
# ---------------------------------------------------------------------

@app.on_event("startup")
async def _startup():
    app.state.pool = await asyncpg.create_pool(
        DB_URL,
        min_size=1,
        max_size=6,
        statement_cache_size=0,  # PgBouncer safe
        max_inactive_connection_lifetime=60.0,
    )

@app.on_event("shutdown")
async def _shutdown():
    pool = getattr(app.state, "pool", None)
    if pool:
        await pool.close()

# ---------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------

def _to_jsonable(obj: Any) -> Any:
    if isinstance(obj, (float, int, str, bool)) or obj is None:
        return obj
    if isinstance(obj, dict):
        return {k: _to_jsonable(v) for k, v in obj.items()}
    if isinstance(obj, list):
        return [_to_jsonable(v) for v in obj]
    try:
        return float(obj)  # Decimals, etc.
    except Exception:
        return str(obj)

# ---------------------------------------------------------------------
# Counties vector tiles (server-side generated by PostGIS)
# ---------------------------------------------------------------------

@app.get("/tiles/counties/{z}/{x}/{y}", response_class=MVTResponse, tags=["tiles"])
async def tiles_counties(z: int, x: int, y: int):
    sql = "SELECT gis.us_counties_mvt($1,$2,$3) AS mvt"
    async with app.state.pool.acquire() as conn:
        row = await conn.fetchrow(sql, z, x, y)
    data = row["mvt"] if row and row["mvt"] else None
    # 204 (No Content) for empty tiles is standard in MVT servers
    return Response(
        content=bytes(data) if data else b"",
        media_type=MVTResponse.media_type,
        headers={"Cache-Control": "public, max-age=3600, s-maxage=3600"},
        status_code=200 if data else 204,
    )

# ---------------------------------------------------------------------
# Property pins vector tiles (points -> MVT)
# ---------------------------------------------------------------------

@app.get("/tiles/properties/{z}/{x}/{y}", response_class=MVTResponse, tags=["tiles"])
async def tiles_properties(z: int, x: int, y: int):
    sql = "SELECT gis.properties_mvt($1,$2,$3) AS mvt"
    async with app.state.pool.acquire() as conn:
        row = await conn.fetchrow(sql, z, x, y)
    data = row["mvt"] if row and row["mvt"] else None
    return Response(
        content=bytes(data) if data else b"",
        media_type=MVTResponse.media_type,
        headers={"Cache-Control": "public, max-age=300, s-maxage=300"},
        status_code=200 if data else 204,
    )

# ---------------------------------------------------------------------
# Minimal property JSON (for click popups)
# ---------------------------------------------------------------------

@app.get("/properties/{property_id}", tags=["properties"])
async def property_details(property_id: str = Path(..., description="Property UUID")):
    sql = """
      SELECT
        id, title, address, city, state,
        bedrooms, bathrooms, square_feet, price
      FROM public.properties
      WHERE id = $1
    """
    async with app.state.pool.acquire() as conn:
        row = await conn.fetchrow(sql, property_id)

    if not row:
        raise HTTPException(status_code=404, detail="Property not found")

    return JSONResponse(
        _to_jsonable({
            "id": str(row["id"]),
            "title": row["title"],
            "address": row["address"],
            "city": row["city"],
            "state": row["state"],
            "bedrooms": row["bedrooms"],
            "bathrooms": row["bathrooms"],
            "square_feet": row["square_feet"],
            "price": float(row["price"]) if row["price"] is not None else None,
        }),
        headers={"Cache-Control": "public, max-age=3600"},
    )

# ---------------------------------------------------------------------
# Health
# ---------------------------------------------------------------------

@app.get("/", tags=["health"])
async def root():
    return {
        "ok": True,
        "service": "risk-map",
        "message": "Vector tiles + Properties enabled",
        "tiles": {
            "counties": "/tiles/counties/{z}/{x}/{y}",
            "properties": "/tiles/properties/{z}/{x}/{y}",
        },
        "json": {
            "property_details": "/properties/{id}",
        },
    }
